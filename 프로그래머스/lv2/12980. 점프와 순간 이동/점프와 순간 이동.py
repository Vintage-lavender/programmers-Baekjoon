#순간이동은 건전지가 닳지 않음
#시작위치는 0
#5000 = 2**3 * 5**4
#탑다운으로 해야하려나...재귀가 무조건 더 오래걸릴듯? 재귀랑 dp를 합하면 모를까...
def solution(n):
    '''
    #풀이1
    #dp: 최소 경우의 수를 기록
    dp = [0]*(n+1)
    for i in range(1,n+1):
        dp[i] = dp[i-1]+1
        if i%2==0: #직전에서 오는게 최소인지 2나눈것에서 오는게 최소인지 비교
            dp[i] = min(dp[i],dp[i//2])
    return dp[n] #런타임에러/시간초과 원인: n의 크기
    '''
    '''
    #풀이2
    answer = 1
    while n!=1: #2로 나눠주다가 홀수 되면 1빼주고 2나누고를 반복하기
        if n%2==0:
            n//=2
        else:
            n-=1
            answer +=1
    return answer #2가 아닌 서로소를 2의 제곱으로 만들기 위해 빼야하는 1의 개수+1
    '''
    #풀이3
    #이진수는 각 자리수가 2의 제곱수이므로 2를 나눌때마다 오른쪽으로 한칸씩 이동함. 
    #하지만 홀수일때는 마지막 자리가 1이고, 한칸을 옮길 수 없으므로 그 1을 빼줘야 함.
    #그래서 1의 개수만큼 베터리를 써야 함
    return bin(n).count('1') #1을 뻬야하는 횟수는 이진수의 1개수로 알 수 있답니다...